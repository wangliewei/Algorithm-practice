
/*
动态规划 ： 空间压缩  跟状态压缩不是一回事

对于一个普遍的二维动归问题，对于该二维表的任意一个位置，
比如说，该位置的值依赖于其左边位置和上边位置，那么其实是不需要申请二维数组的，
申请一个数组就够了；
分析：首先看第一行，第一行的每个位置肯定只依赖其左边位置，因为它没有上边位置，对于最左边一列的每个位置
肯定只依赖其上边位置，因为它没有左边

实施： 先把第一行填到申请的arr中，然后更新，把arr更新成第二行的值，依次类推，即可得到整张表



情况二：如果对于任意一个位置，其依赖左上角位置和上面的位置，那么改成从右往左更新即可

情况三：如果对于任意一个位置，其依赖左上角位置和上面的位置和左边的位置，亦然可以

情况四：如果对于任意一个位置，其依赖上上行的某个位置和上面的位置和左边的位置，那么只需申请三个arr即可，
交替更新

情况五：如果该二维表列数很多很多，那么依然不是很省空间，此时只需要申请一个行数大小的arr，横向更新即可

这种技巧的用处在于：
面试的时候可以跟面试官聊一下，或者看别人写的代码时可能会看到更容易明白，或者有空间复杂度要求的时候
自己写的时候没什么必要，为了好理解，
 */





/*
把空间压缩技巧用到极致的一道题： 因为此题连arr都不要，只需要几个变量即可
给定两个字符串，求最长公共子串！ （子串和子数组要求是连续的， 子序列不要求连续）

思路：分别以两个字符串为行和列构造二维表，dp[i][j]表示同时以str1的第i个字符结尾和以str2的第j个字符结尾
的最长公共子串的长度；
那么，只要str[i] != str[j]，直接把dp[i][j]设为0；如果相等，设为其左上角位置加1即可

答案即整张表每个位置的最大值

空间压缩：保存第一行和第一列值不为0的，然后沿着斜线往下推








此法复杂度为n^2, 并不是最优解，最优解是O(N)的，后缀数组



 */


public class spaceYaSuo {



}



















